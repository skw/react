***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
С React вы просто передаете функцию-обработчик нужного события как аргумент, почти также, как делали это в HTML. А с помощью механизма псевдособытий, React гарантирует, что все события будут вести себя одинаково во всех браузерах. Действительно, React умеет работать с событиями при их всплытии и перехвате. И все события, которые попадут в обработчик будут вести себя в соответствии со [спецификациией W3C](http://www.w3.org/TR/DOM-Level-3-Events/), при этом неважно каким браузером вы пользуетесь.
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
**Автоматическое связывание:** Когда в JavaScript создаются функции-колбэки, вам надо привязать метод к тому объекту, на котором он будет вызываться, так чтобы значение `this` было корректным. С React привязка метода к компоненту происходит автоматически ([кроме тех случаев, когда вы используете классы ES6](/react/docs/reusable-components.html#no-autobinding)). И делается это с минимальной нагрузкой на процессор и память.
***REMOVED***
**Делегирование событий:** На самом же деле, React добавялет обработчики событий не к узлам дерева. Сразу после запуска, React начинает прослушивать все события с самого верхнего уровня, используя единый слушатель. Когда добавляется новый компонент или удаляется старый, обработчики событий просто добавляются или удаляются из памяти React. И когда событие наступает, React уже заранее знает кому из обработчиков его передать. Когда в памяти больше не остается обработчиков, они перестают работать. Если хотите узнать о том, почему такая механика так быстро работает, посмотрите [отличный пост в блоге David Walsh](http://davidwalsh.name/event-delegate).
***REMOVED***
***REMOVED***
***REMOVED***
React считает интерфейсы обыкновенными конечными автоматами. Работать с интерфейсом становится проще, если представлять его как конечный автомат, который меняет состояния и отрисовывает их.
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
Чтобы сообщить React о том, что данные изменились, вы вызываете метод `setState(data, callback)`. В этом методе происходит обновление состояния `this.state` новыми данными из `data`, и компонент отрисуется заново. После этого, вызывается функция `callback`. Но вы редко будете ей пользоваться, ведь React сам обновляет интерфейс.
***REMOVED***
## В каких компонентах хранить состояние?
***REMOVED***
Большинство компонентов должны просто брать данные из `props` и отрисовывать их. Но иногда вам надо реагировать на действия пользователя, делать запросы на сервер или просто сделать что-то по таймеру. В таких случаях используйте состояние.
***REMOVED***
**Старайтесь делать компоненты без состояния.** Следуя этому правилу, вы будете выносить работу с состоянием с уровня представления в другие, более подходящие места. Тем самым, снижать сложность приложения, упрощая его понимание.
***REMOVED***
Основной принцип такой: создаются несколько компонентов без состояния, которые формируют дерево. Они будут заниматься только отрисовкой данных. А все данные для них будут у родительского компонента, который будет на вершине этого дерева компонентов. Он и будет передавать данные дочерним узлам через `props`. Этот компонент с общим состоянием содержит в себе всю логику взаимодействия, а дочерние компоненты будут только отрисовывать данные, которые будут у них в `props`.
***REMOVED***
***REMOVED***
***REMOVED***
**Состояние должно содержать данные, которые нужны для обновления интерфейса.** В реальных приложениях такие данные крайне малы и передаются, обычно, через JSON-файлы. Когда создаете компонент с состоянием, старайтесь поместить в него минимум данных. А уже внутри метода `render()` вычисляйте остальные данные, используя значения из состояния. 
Со временем вы увидите, что написание приложений таким способом позволяет создавать более стройные и устойчивые к изменениям приложения. Добавление в состояние лишних данных требует от вас дополнительных затрат на их синхронизацию. Но этого можно избежать, если позволить React делать все эти вычисления за вас.
***REMOVED***
***REMOVED***
***REMOVED***
Состояние `this.state` должно содержать минимум данных, необходимых  для отображения интерфейса. Поэтому не стоит ложить туда:
***REMOVED***
* **Вычисляемые данные:** Вам не надо думать о тех данных, которые надо вычислять через данные состояния — лучше позаботьтесь об интерфейсе, а все вычисления делайте в методе `render()`. Например, если в состоянии хранится список элементов и вам надо вывести его размер в виде строки. Напишите `this.state.listItems.length + ' элементов'` в методе `render()`. Это будет правильнее, чем хранить размер списка в состоянии.
* **Компоненты React:** Создавайте их в методе `render()` опираясь на данные из `props` и `this.state`.
* **Значения, повторяющие `props`:** старайтесь использовать `props` только как источник данных для отрисовки. Хранить значения `props` в состоянии допускатеся, только если вам надо где-то хранить их прошлые значения, ведь `props` могут измениться после отрисовки родительского компонента.
